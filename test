import { Injectable } from '@angular/core';
import { AuthConfig, OAuthService } from 'angular-oauth2-oidc';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, filter, switchMap, tap } from 'rxjs/operators';

/**
 * Service for managing authentication with an OAuth2/OpenID Connect provider.
 */
@Injectable({
  providedIn: 'root'
})
export class AuthService {

  private loggedInSubject$: BehaviorSubject<boolean>;
  public loggedIn$: Observable<boolean>;

  /**
   * Creates an instance of AuthService.
   *
   * @param oauthService The OAuthService instance to use for authentication.
   */
  constructor(private oauthService: OAuthService) {
    this.loggedInSubject$ = new BehaviorSubject<boolean>(this.oauthService.hasValidAccessToken());
    this.loggedIn$ = this.loggedInSubject$.asObservable();
  }

  /**
   * Configures the OAuthService instance with the given AuthConfig.
   *
   * @param authConfig The AuthConfig object to use for configuration.
   */
  public configure(authConfig: AuthConfig) {
    this.oauthService.configure(authConfig);
    this.oauthService.loadDiscoveryDocumentAndTryLogin().then(() => {
      if (this.oauthService.hasValidAccessToken()) {
        this.loggedInSubject$.next(true);
      }
    });
  }

  /**
   * Initiates the login flow with the OAuth2/OpenID Connect provider.
   */
  public login() {
    this.oauthService.initLoginFlow();
  }

  /**
   * Logs the user out of the application and revokes their access token.
   */
  public logout() {
    this.oauthService.logOut();
    this.loggedInSubject$.next(false);
  }

  /**
   * Returns an Observable that emits the access token for the logged-in user.
   *
   * @returns An Observable that emits the access token for the logged-in user.
   */
  public getAccessToken(): Observable<string> {
    return this.loggedIn$.pipe(
      filter(loggedIn => loggedIn),
      switchMap(() => this.oauthService.getAccessToken()),
      catchError(error => throwError(error))
    );
  }

  /**
   * Returns an Observable that emits the ID token for the logged-in user.
   *
   * @returns An Observable that emits the ID token for the logged-in user.
   */
  public getIdToken(): Observable<string> {
    return this.loggedIn$.pipe(
      filter(loggedIn => loggedIn),
      switchMap(() => this.oauthService.getIdToken()),
      catchError(error => throwError(error))
    );
  }

  /**
   * Returns an Observable that emits the expiration time for the access token of the logged-in user.
   *
   * @returns An Observable that emits the expiration time for the access token of the logged-in user.
   */
  public getAccessTokenExpiration(): Observable<number> {
    return this.loggedIn$.pipe(
      filter(loggedIn => loggedIn),
      switchMap(() => this.oauthService.getAccessTokenExpiration()),
      catchError(error => throwError(error))
    );
  }

  /**
   * Returns an Observable that refreshes the access token for the logged-in user.
   *
   * @returns An Observable that refreshes the access token for the logged-in user.
   */
  public refreshToken(): Observable<void> {
    return this.loggedIn$.pipe(
      filter(loggedIn => loggedIn),
      switchMap(() => this.oauthService.refreshToken()),
      tap(() => this.loggedInSubject$.next(true)),
      catchError(error => {
        this.loggedInSubject$.next(false);
        return throwError(error);
      })
    );
  }

  /**
   * Returns a boolean indicating whether the logged-in user has a valid access token.
   *
   * @returns A boolean indicating whether the logged-in user has a valid access token.
   */
  public hasValidAccessToken(): boolean {
    return this.oauthService.hasValidAccessToken();
  }

  /**
   * Returns the identity claims for the logged-in user.
   *
   * @returns The identity claims for the logged-in user.
   */
  public getIdentityClaims(): any {
    return this.oauthService.getIdentityClaims();
  }

  /**
   * Returns the first name of the logged-in user.
   *
   * @returns The first name of the logged-in user.
   */
  public getFirstName(): string {
    const identityClaims = this.oauthService.getIdentityClaims();
    return identityClaims ? identityClaims['given_name'] : null;
  }

  /**
   * Returns the last name of the logged-in user.
   *
   * @returns The last name of the logged-in user.
   */
  public getLastName(): string {
    const identityClaims = this.oauthService.getIdentityClaims();
    return identityClaims ? identityClaims['family_name'] : null;
  }

  /**
   * Returns the user ID of the logged-in user.
   *
   * @returns The user ID of the logged-in user.
   */
  public getUserId(): string {
    const identityClaims = this.oauthService.getIdentityClaims();
    return identityClaims ? identityClaims['sub'] : null;
  }

  /**
   * Returns the full name of the logged-in user.
   *
   * @returns The full name of the logged-in user.
   */
  public getFullName(): string {
    const identityClaims = this.oauthService.getIdentityClaims();
    const givenName = identityClaims ? identityClaims['given_name'] : '';
    const familyName = identityClaims ? identityClaims['family_name'] : '';
    return givenName + ' ' + familyName;
  }

}

import { TestBed } from '@angular/core/testing';
import { AuthConfig, OAuthService } from 'angular-oauth2-oidc';
import { BehaviorSubject } from 'rxjs';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let authService: AuthService;
  let oauthServiceSpy: jasmine.SpyObj<OAuthService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('OAuthService', [
      'configure',
      'loadDiscoveryDocumentAndTryLogin',
      'initLoginFlow',
      'logOut',
      'getAccessToken',
      'getIdToken',
      'getAccessTokenExpiration',
      'refreshToken',
      'hasValidAccessToken',
      'getIdentityClaims'
    ]);

    TestBed.configureTestingModule({
      providers: [
        AuthService,
        { provide: OAuthService, useValue: spy }
      ]
    });

    authService = TestBed.inject(AuthService);
    oauthServiceSpy = TestBed.inject(OAuthService) as jasmine.SpyObj<OAuthService>;
  });

  it('should be created', () => {
    expect(authService).toBeTruthy();
  });

  describe('configure', () => {
    it('should configure the OAuthService instance with the given AuthConfig', () => {
      const authConfig: AuthConfig = {
        clientId: 'test-client-id',
        issuer: 'https://test-issuer.com',
        redirectUri: 'https://test-redirect-uri.com',
        responseType: 'code',
        scope: 'openid profile email'
      };

      authService.configure(authConfig);

      expect(oauthServiceSpy.configure).toHaveBeenCalledWith(authConfig);
    });

    it('should load the discovery document and try to login', async () => {
      const authConfig: AuthConfig = {
        clientId: 'test-client-id',
        issuer: 'https://test-issuer.com',
        redirectUri: 'https://test-redirect-uri.com',
        responseType: 'code',
        scope: 'openid profile email'
      };

      await authService.configure(authConfig);

      expect(oauthServiceSpy.loadDiscoveryDocumentAndTryLogin).toHaveBeenCalled();
    });

    it('should set the logged in state to true if a valid access token is present', async () => {
      const authConfig: AuthConfig = {
        clientId: 'test-client-id',
        issuer: 'https://test-issuer.com',
        redirectUri: 'https://test-redirect-uri.com',
        responseType: 'code',
        scope: 'openid profile email'
      };

      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      await authService.configure(authConfig);

      expect(authService.loggedInSubject$.getValue()).toBeTrue();
    });

    it('should set the logged in state to false if a valid access token is not present', async () => {
      const authConfig: AuthConfig = {
        clientId: 'test-client-id',
        issuer: 'https://test-issuer.com',
        redirectUri: 'https://test-redirect-uri.com',
        responseType: 'code',
        scope: 'openid profile email'
      };

      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      await authService.configure(authConfig);

      expect(authService.loggedInSubject$.getValue()).toBeFalse();
    });
  });

  describe('login', () => {
    it('should initiate the login flow with the OAuth2/OpenID Connect provider', () => {
      authService.login();

      expect(oauthServiceSpy.initLoginFlow).toHaveBeenCalled();
    });
  });

  describe('logout', () => {
    it('should log the user out of the application and revoke their access token', () => {
      authService.logout();

      expect(oauthServiceSpy.logOut).toHaveBeenCalled();
      expect(authService.loggedInSubject$.
  });

  describe('getAccessToken', () => {
    it('should return an Observable that emits the access token for the logged-in user', () => {
      const accessToken = 'test-access-token';
      oauthServiceSpy.getAccessToken.and.returnValue(accessToken);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      authService.getAccessToken().subscribe(token => {
        expect(token).toEqual(accessToken);
      });
    });

    it('should throw an error if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      authService.getAccessToken().subscribe(
        () => {},
        error => {
          expect(error).toBeTruthy();
        }
      );
    });
  });

  describe('getIdToken', () => {
    it('should return an Observable that emits the ID token for the logged-in user', () => {
      const idToken = 'test-id-token';
      oauthServiceSpy.getIdToken.and.returnValue(idToken);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      authService.getIdToken().subscribe(token => {
        expect(token).toEqual(idToken);
      });
    });

    it('should throw an error if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      authService.getIdToken().subscribe(
        () => {},
        error => {
          expect(error).toBeTruthy();
        }
      );
    });
  });

  describe('getAccessTokenExpiration', () => {
    it('should return an Observable that emits the expiration time for the access token of the logged-in user', () => {
      const expirationTime = Date.now() + 3600000;
      oauthServiceSpy.getAccessTokenExpiration.and.returnValue(expirationTime);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      authService.getAccessTokenExpiration().subscribe(time => {
        expect(time).toEqual(expirationTime);
      });
    });

    it('should throw an error if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      authService.getAccessTokenExpiration().subscribe(
        () => {},
        error => {
          expect(error).toBeTruthy();
        }
      );
    });
  });

  describe('refreshToken', () => {
    it('should return an Observable that refreshes the access token for the logged-in user', () => {
      oauthServiceSpy.refreshToken.and.returnValue(Promise.resolve());
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      authService.refreshToken().subscribe(() => {
        expect(oauthServiceSpy.refreshToken).toHaveBeenCalled();
        expect(authService.loggedInSubject$.getValue()).toBeTrue();
      });
    });

    it('should set the logged in state to false and throw an error if the refresh token fails
  });

  describe('getIdentityClaims', () => {
    it('should return the identity claims for the logged-in user', () => {
      const identityClaims = { sub: 'test-sub', given_name: 'Test', family_name: 'User' };
      oauthServiceSpy.getIdentityClaims.and.returnValue(identityClaims);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      const result = authService.getIdentityClaims();

      expect(result).toEqual(identityClaims);
    });

    it('should throw an error if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      authService.getIdentityClaims().subscribe(
        () => {},
        error => {
          expect(error).toBeTruthy();
        }
      );
    });
  });

  describe('getFirstName', () => {
    it('should return the first name of the logged-in user', () => {
      const identityClaims = { sub: 'test-sub', given_name: 'Test', family_name: 'User' };
      oauthServiceSpy.getIdentityClaims.and.returnValue(identityClaims);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      const result = authService.getFirstName();

      expect(result).toEqual(identityClaims.given_name);
    });

    it('should return null if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      const result = authService.getFirstName();

      expect(result).toBeNull();
    });
  });

  describe('getLastName', () => {
    it('should return the last name of the logged-in user', () => {
      const identityClaims = { sub: 'test-sub', given_name: 'Test', family_name: 'User' };
      oauthServiceSpy.getIdentityClaims.and.returnValue(identityClaims);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      const result = authService.getLastName();

      expect(result).toEqual(identityClaims.family_name);
    });

    it('should return null if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      const result = authService.getLastName();

      expect(result).toBeNull();
    });
  });

  describe('getUserId', () => {
    it('should return the user ID of the logged-in user', () => {
      const identityClaims = { sub: 'test-sub', given_name: 'Test', family_name: 'User' };
      oauthServiceSpy.getIdentityClaims.and.returnValue(identityClaims);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      const result = authService.getUserId();

      expect(result).toEqual(identityClaims.sub);
    });

    it('should return null if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      const result = authService.getUserId();

      expect(result).toBeNull();
    });
  });

  describe('getFullName', () => {
    it('should return the full name of the logged-in user', () => {
      const identityClaims = { sub: 'test-sub', given_name: 'Test', family_name: 'User' };
      oauthServiceSpy.getIdentityClaims.and.returnValue(identityClaims);
      oauthServiceSpy.hasValidAccessToken.and.returnValue(true);

      const result = authService.getFullName();

      expect(result).toEqual(identityClaims.given_name + ' ' + identityClaims.family_name);
    });

    it('should return an empty string if the user is not logged in', () => {
      oauthServiceSpy.hasValidAccessToken.and.returnValue(false);

      const result = authService.getFullName();

      expect(result).toEqual('');
    });
  });

});

export const authConfig: AuthConfig = {
  issuer: 'https://<your-pingfederate-server>/as/authorization.oauth2', // The authorization server URL
  redirectUri: window.location.origin + '/callback', // The redirect URI after successful authentication
  clientId: '<your-client-id>', // The client ID
  scope: 'openid profile email', // The scopes requested during authentication
  responseType: 'code', // The response type to use (code for authorization code flow)
  showDebugInformation: true, // Set to true to show debug information in the console
  timeoutFactor: 0.01, // The timeout factor to use for HTTP requests
  useSilentRefresh: true, // Set to true to use silent refresh for token renewal
  silentRefreshRedirectUri: window.location.origin + '/silent-refresh.html', // The redirect URI for silent refresh
  silentRefreshTimeout: 5000, // The timeout for silent refresh
  sessionChecksEnabled: true // Set to true to enable session checks
};

import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, switchMap } from 'rxjs/operators';
import { OAuthService } from 'angular-oauth2-oidc';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  constructor(private oauthService: OAuthService) {}

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (this.oauthService.hasValidAccessToken()) {
      request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${this.oauthService.getAccessToken()}`,
          'X-CSRF-TOKEN': this.getCsrfToken()
        }
      });
    }
    return next.handle(request).pipe(
      catchError((error: any) => {
        if (error instanceof HttpErrorResponse && error.status === 401) {
          return this.oauthService.refreshToken().pipe(
            switchMap(() => {
              request = request.clone({
                setHeaders: {
                  Authorization: `Bearer ${this.oauthService.getAccessToken()}`,
                  'X-CSRF-TOKEN': this.getCsrfToken()
                }
              });
              return next.handle(request);
            }),
            catchError(refreshError => {
              this.oauthService.logOut();
              return throwError(refreshError);
            })
          );
        } else if (error instanceof HttpErrorResponse && error.status === 403 && error.error && error.error.message === 'Invalid CSRF Token') {
          // Handle CSRF token error here.
          // You may want to prompt the user to refresh the page or log out and log back in.
          console.error('CSRF token error:', error);
          return throwError(error);
        } else {
          return throwError(error);
        }
      })
    );
  }

  private getCsrfToken(): string {
    // Implement your logic to retrieve the CSRF token here.
    // You can use Angular's built-in support for CSRF protection
    // or a custom implementation depending on your requirements.
    return 'your-csrf-token-here';
  }
}
